;(function(win, doc, lib) {
    /**
     * @namespace lib
     */

    var parseInt = win.parseInt;

    function isPlainObject(obj) {
        return obj != null && typeof obj == 'object' && Object.getPrototypeOf(obj) == Object.prototype;
    }

    function throttle(func, wait) { // 节流函数
        var context, args, result;
        var timeout = null;
        var previous = 0;
        var later = function() {
            previous = Date.now();
            timeout = null;
            result = func.apply(context, args);
        };
        return function() {
            var now = Date.now();
            var remaining = wait - (now - previous);
            context = this;
            args = arguments;
            if (remaining <= 0) {
                clearTimeout(timeout);
                timeout = null;
                previous = now;
                result = func.apply(context, args);
            } else if (!timeout) {
                timeout = setTimeout(later, remaining);
            }
            return result;
        };
    }

    function getCssText(cssRuleObj) {
        var cssText = '';
        Object.keys(cssRuleObj).forEach(function(prop) {
            cssText += prop + ':' + cssRuleObj[prop] + ';';
        });
        return cssText;
    }

    var ua = navigator.userAgent;
    var isFirefox = !!ua.match(/Firefox/i);
    var isIEMobile = !!ua.match(/IEMobile/i);
    var cssPrefix = isFirefox ? '-moz-' : isIEMobile ? '-ms-' : '-webkit-';
    var stylePrefix = isFirefox ? 'Moz' : isIEMobile ? 'ms' : 'webkit';

    var supportSticky = (function() {
        var element = doc.createElement('div');
        var elementStyle = element.style;
        elementStyle.cssText = 'position:' + cssPrefix + 'sticky;position:sticky;';
        return elementStyle.position.indexOf('sticky') != -1;
    }) ();

    /**
     * @class  lib.sticky
     * @param {(string|HTMLElement)} element 一个DOM元素，或者是它的CSS选择器
     * @param {object} options 配置参数
     * @param {(string|HTMLElement)} options.element 如果没有指定上面的参数element，可以把element放到options中做为一个属性
     * @param {number} [options.top=0] （非必填）吸顶时元素距离视口顶部的高度，默认值为0
     * @param {boolean} [options.withinParent=false] （非必填，仅适用于Android）元素的sticky效果是否限制在父元素中，默认值为false
     */
    function Sticky(element, options) {
        if (!options && isPlainObject(element)) {
            options = element;
            element = options.element;
        }
        options = options || {};
        if (element.nodeType != doc.ELEMENT_NODE && typeof element == 'string') {
            element = doc.querySelector(element);
        }
        var self = this;
        self.element = element;
        self.top = options.top || 0;
        self.withinParent = options.withinParent == undefined ? false : options.withinParent;
        self.init();
    }

    Sticky.prototype = {
        /** @lends Sticky.prototype */
        constructor: Sticky,

        /**
         * 初始化实例
         * @function lib.sticky#init
         */
        init: function() {
            var self = this;
            var element = self.element;
            var elementStyle = element.style;
            elementStyle[stylePrefix + 'Transform'] = 'translateZ(0)'; // XXX: 解决闪动问题
            elementStyle['transform'] = 'translateZ(0)';
            self._originCssText = elementStyle.cssText;
            if (supportSticky) {
                elementStyle.position = cssPrefix + 'sticky';
                elementStyle.position = 'sticky';
                elementStyle.top = self.top + 'px';
            } else {
                self._simulateSticky();
                self._bindResize();
            }
        },

        _bindResize: function() { // FIXME: 适应横屏
            var self = this;
            var isAndroid = (/android/gi).test(navigator.appVersion);
            var resizeEvent = self._resizeEvent = 'onorientationchange' in win ? 'orientationchange' : 'resize';
            var resizeHandler = self._resizeHandler = function() {
                setTimeout(function() {
                    self.refresh();
                }, isAndroid ? 200 : 0);
            };
            win.addEventListener(resizeEvent, resizeHandler, false);
        },

        /**
         * 重置实例，如果withinParent设置为true，且父元素高度发生变化，请立即调用此方法
         * @function lib.sticky#refresh
         */
        refresh: function() {
            var self = this;
            if (supportSticky) {
                return;
            }
            self._detach();
            self._simulateSticky();
        },

        _addPlaceholder: function(computedStyle) {
            var self = this;
            var element = self.element;
            var placeholderElement;
            var placeholderElementStyle;
            var positionValue = computedStyle.position;

            // 如果position属性为static或relative，则在sticky元素的原位置添加一个占位元素
            if (['static', 'relative'].indexOf(positionValue) != -1) {
                placeholderElement = self._placeholderElement = doc.createElement('div');
                var width = parseInt(computedStyle.width) + parseInt(computedStyle.marginLeft) + parseInt(computedStyle.marginRight);
                var height = parseInt(computedStyle.height);
                if (computedStyle.boxSizing != 'border-box') {
                    width += parseInt(computedStyle.borderLeftWidth) + parseInt(computedStyle.borderRightWidth) // XXX: 米3手淘WebView取不到margin、padding、border的值
                            + parseInt(computedStyle.paddingLeft) + parseInt(computedStyle.paddingRight);
                    height += parseInt(computedStyle.borderTopWidth) + parseInt(computedStyle.borderBottomWidth)
                            + parseInt(computedStyle.paddingTop) + parseInt(computedStyle.paddingBottom);
                }
                placeholderElement.style.cssText = getCssText({
                    display: 'none',
                    visibility: 'hidden',
                    width: width + 'px',
                    height: height + 'px',
                    margin: 0,
                    'margin-top': computedStyle.marginTop, // FIXME: 防止多个sticky元素之间的margin collapse
                    'margin-bottom': computedStyle.marginBottom,
                    border: 0,
                    padding: 0,
                    float: computedStyle.float || computedStyle.cssFloat
                });
                element.parentNode.insertBefore(placeholderElement, element);
            }

            return placeholderElement;
        },

        _simulateSticky: function() {
            var self = this;
            var element = self.element;
            var stickyTop = self.top;
            var elementStyle = element.style;
            var rect = element.getBoundingClientRect();
            var computedStyle = getComputedStyle(element, '');
            var parentElement = element.parentNode;
            var parentComputedStyle = getComputedStyle(parentElement, '');
            var placeholderElement = self._addPlaceholder(computedStyle);
            var withinParent = self.withinParent;

            var originCssText = self._originCssText;
            var thresholdTop = rect.top - stickyTop + win.pageYOffset; // 加上window.pageYOffset应对浏览器记住页面上次滚动位置的情形，因为getBoundingClientRect获取的是元素相对与视口的位置
            var thresholdBottom = parentElement.getBoundingClientRect().bottom
                    - parseInt(parentComputedStyle.paddingBottom)
                    - parseInt(parentComputedStyle.borderBottomWidth) // XXX: 米3手淘WebView取不到borderBottom的值
                    - parseInt(computedStyle.marginBottom)
                    - rect.height - stickyTop + win.pageYOffset;
            var stickyInCssText = originCssText + getCssText({ // 在父元素中的样式
                position: 'fixed',
                top: stickyTop + 'px',
                width: computedStyle.width,
                'margin-top': 0
            });
            var stickyOutCssText = originCssText + getCssText({ // 向下滚动超出父元素的样式
                position: 'absolute',
                top: thresholdBottom + 'px',
                width: computedStyle.width
            });
            var curState = 1; // 1-普通状态，2-在父元素中，3-向下滚动超出父元素
            var scrollHandler = self._scrollHandler = throttle(function() { // 对scroll事件的处理函数进行节流
                var ypos = win.pageYOffset;
                if (ypos < thresholdTop) {
                    if (curState != 1) {
                        elementStyle.cssText = originCssText;
                        if (placeholderElement) {
                            placeholderElement.style.display = 'none';
                        }
                        curState = 1;
                    }
                } else if ((!withinParent && ypos >= thresholdTop) ||
                    (withinParent && ypos >= thresholdTop && ypos < thresholdBottom)) {
                    if (curState != 2) {
                        elementStyle.cssText = stickyInCssText;
                        if (placeholderElement && curState != 3) {
                            placeholderElement.style.display = 'block';
                        }
                        curState = 2;
                    }
                } else if (withinParent) {
                    if (curState != 3) {
                        elementStyle.cssText = stickyOutCssText;
                        if (placeholderElement && curState != 2) {
                            placeholderElement.style.display = 'block';
                        }
                        curState = 3;
                    }
                }
            }, 100);
            win.addEventListener('scroll', scrollHandler, false);

            if (win.pageYOffset >= thresholdTop) { // FIXME: 为保证destroy后再调用init能马上展示sticky效果
                var dummyEvent = doc.createEvent('HTMLEvents');
                dummyEvent.initEvent('scroll', true, true);
                win.dispatchEvent(dummyEvent);
            }
        },

        _detach: function() {
            var self = this;
            var element = self.element;
            element.style.cssText = self._originCssText;
            if (!supportSticky) {
                var placeholderElement = self._placeholderElement;
                if (placeholderElement) {
                    element.parentNode.removeChild(placeholderElement);
                }
                win.removeEventListener('scroll', self._scrollHandler, false);
            }
        },

        /**
         * 销毁实例
         * @function lib.sticky#destroy
         */
        destroy: function() {
            var self = this;
            self._detach();
            var elementStyle = self.element.style;
            elementStyle.removeProperty(cssPrefix + 'transform');
            elementStyle.removeProperty('transform');
            if (!supportSticky) {
                win.removeEventListener(self._resizeEvent, self._resizeHandler, false);
            }
        }
    };

    lib.sticky = Sticky;

}) (window, document, window['lib'] || (window['lib'] = {}));
