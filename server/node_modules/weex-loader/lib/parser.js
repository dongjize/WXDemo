'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseWeex = parseWeex;
exports.parseTemplate = parseTemplate;
exports.parseStyle = parseStyle;
exports.parseScript = parseScript;

var _blocker = require('weex-transformer/lib/blocker');

var _blocker2 = _interopRequireDefault(_blocker);

var _weexTemplater = require('weex-templater');

var _weexTemplater2 = _interopRequireDefault(_weexTemplater);

var _weexStyler = require('weex-styler');

var _weexStyler2 = _interopRequireDefault(_weexStyler);

var _weexScripter = require('weex-scripter');

var _weexScripter2 = _interopRequireDefault(_weexScripter);

var _md = require('md5');

var _md2 = _interopRequireDefault(_md);

var _config = require('./config');

var _util = require('./util');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function parseWeex(loader, params, source, map, deps, elementName) {
  return new Promise(
  // separate source into <element>s, <template>, <style>s and <script>s
  separateBlocks(source, deps || []))
  // pre-parse non-javascript parts
  .then(preParseBlocks(loader, params, map))
  // join blocks together and parse as javascript finally
  .then(parseBlocks(loader, params, map, elementName));
}

function separateBlocks(source, deps) {
  return function (resolve, reject) {
    _blocker2.default.format(source, function (err, ret) {
      if (err) {
        reject(err);
      } else {
        ret.deps = deps;
        resolve(ret);
      }
    });
  };
}

function preParseBlocks(loader, params, map) {
  return function (blocks) {
    var deps = blocks.deps;
    var elements = blocks.elements;
    var template = blocks.template;
    var styles = blocks.styles;
    var scripts = blocks.scripts;
    var config = blocks.config;
    var data = blocks.data;

    var promises = [Promise.resolve(), Promise.resolve(), Promise.resolve(), Promise.resolve(scripts), Promise.resolve(deps), Promise.resolve(config), Promise.resolve(data)];
    var content = void 0;
    // pre-parse sub elements
    if (elements) {
      (function () {
        var elPromises = [];
        Object.keys(elements).forEach(function (key) {
          var el = elements[key];
          // record original positions of each <element>
          map.setElementPosition(el.name, el.line, el.column);
          elPromises.push(parseWeex(loader, params, el.content, map, deps, el.name));
        });
        promises[0] = Promise.all(elPromises);
      })();
    }
    // pre-parse template
    if (template) {
      content = template.content;
      promises[1] = parseTemplate(loader, params, content, deps);
    }
    // pre-parse styles
    if (styles) {
      content = styles.reduce(function (pre, cur) {
        return pre + '\n' + cur.content;
      }, '');
      promises[2] = parseStyle(loader, params, content);
    }
    return Promise.all(promises);
  };
}

function parseBlocks(loader, params, map, elementName) {
  return function (results) {
    var elements = results[0] || [];
    var template = results[1];
    var style = results[2];
    var scripts = results[3];
    var deps = results[4] || [];
    var configResult = results[5];
    var dataResult = results[6];

    var content = '';
    var config = {};
    var data = void 0;

    var mapOffset = { basic: 0, subs: [] };

    if (scripts) {
      // record original and generated position of each <script>
      // the generated content is begin with empty string
      // so later the template, styles and elements will be appended/prepended
      // and mapOffset.basic will record lines of prepended *required* content
      content += scripts.reduce(function (prev, next, i) {
        // length of previous content
        var line = prev.split(/\r?\n/g).length + 1;
        var column = 1;
        var oriLine = next.line;
        var oriColumn = next.column;
        mapOffset.subs.push({
          original: { line: oriLine, column: oriColumn },
          generated: { line: line, column: column },
          // length of next content
          length: next.content.split(/\r?\n/g).length
        });
        return prev + '\n;' + next.content;
      }, '');
    }

    var requireContent = '';
    if (deps.length) {
      (function () {
        var entryElementName = (0, _util.parseElementNameByPath)(params.resourcePath);
        requireContent += deps.filter(function (dep) {
          if ((0, _util.parseElementNameByPath)(dep) === entryElementName) {
            console.warn('[Warn]: "' + dep + '" cannot include <' + entryElementName + '> itself.');
            return false;
          }
          return true;
        }).map(function (dep) {
          return (0, _util.depHasRequired)(content, dep) ? 'require("' + dep + '");' : '';
        }).join('\n');
        if (requireContent) {
          // length of implicitly requires
          mapOffset.basic = requireContent.split(/\r?\n/g).length;
          content = requireContent + '\n' + content;
        }
      })();
    }

    if (template) {
      // append template content, not impact sourcemap
      content += '\n;module.exports.template = module.exports.template || {}' + '\n;Object.assign(module.exports.template, ' + template + ')';
    }

    if (style) {
      // append style content, not impact sourcemap
      content += '\n;module.exports.style = module.exports.style || {}' + '\n;Object.assign(module.exports.style, ' + style + ')';
    }

    // prepare entry config
    if (configResult) {
      config = new Function('return ' + configResult.content.replace(/\n/g, ''))();
    }
    config.transformerVersion = _config.transformerVersion;
    config = JSON.stringify(config, null, 2);

    // prepare entry data
    if (dataResult) {
      data = new Function('return ' + dataResult.content.replace(/\n/g, ''))();
      data = JSON.stringify(data, null, 2);
    }

    return parseScript(loader, params, content, { config: config, data: data, elementName: elementName, elements: elements, map: map, mapOffset: mapOffset });
  };
}

function parseTemplate(loader, params, source, deps) {
  return new Promise(function (resolve, reject) {
    _weexTemplater2.default.parse(source, function (err, obj) {
      if (err) {
        reject(err);
      } else {
        (0, _util.appendToWarn)(loader, obj.log);
        // push valid obj.deps to deps
        if (deps && obj.deps) {
          obj.deps.map(function (dep) {
            return (0, _util.checkFileExist)(dep, params.resourcePath);
          }).forEach(function (dep) {
            if (dep) {
              deps.push(dep);
            }
          });
        }
        // parse json to string and treat function specially
        var target = JSON.stringify(obj.jsonTemplate, _util.stringifyFunction, '  ');
        target = target.replace(_util.FUNC_START_REG, '').replace(_util.FUNC_END_REG, '');
        resolve(target);
      }
    });
  });
}

function parseStyle(loader, params, source) {
  return new Promise(function (resolve, reject) {
    _weexStyler2.default.parse(source, function (err, obj) {
      if (err) {
        reject(err);
      } else {
        (0, _util.appendToWarn)(loader, obj.log);
        resolve(JSON.stringify(obj.jsonStyle, null, 2));
      }
    });
  });
}

function parseScript(loader, params, source, env) {
  var config = env.config;
  var data = env.data;
  var elementName = env.elementName;
  var elements = env.elements;
  var map = env.map;
  var mapOffset = env.mapOffset;

  // the entry component has a special resource query and not a sub element tag

  var isEntry = params.resourceQuery.entry === true && !elementName;

  // resolve component name
  var name = isEntry ? (0, _md2.default)(source) : elementName || params.resourceQuery.name || (0, _util.getNameByPath)(params.resourcePath);

  // join with elements deps
  // 2 more lines between each element and the end
  map && map.start();
  var prefix = (elements || []).reduce(function (prev, next, index) {
    var prevLength = prev.split(/\r?\n/g).length;
    var nextLength = next.split(/\r?\n/g).length;
    // record generated positions of each <element>
    map && map.addElement(name, index, prevLength, nextLength);
    return prev + next + ';\n\n';
  }, '');

  // fix data option from an object to a function
  var target = _weexScripter2.default.fix(source);

  // wrap with __weex_define__(name, [], (r, e, m) {...})
  // 1 more line at start, 1 more line at end
  target = target.replace(_util.MODULE_EXPORTS_REG, '__weex_module__.exports').replace(_util.REQUIRE_REG, '__weex_require__($1$2$1)');
  target = ';__weex_define__("@weex-component/' + name + '", [], ' + 'function(__weex_require__, exports, __weex_module__)' + '{\n' + target + '\n})';

  // record mapOffset into sourcemap
  if (mapOffset) {
    (function () {
      // length of generated prefix (elements) and basic (implicitly requires)
      var preLines = prefix.split(/\r?\n/g).length + mapOffset.basic;
      mapOffset.subs.forEach(function (info) {
        map.addScript(elementName || name, info, preLines);
      });
    })();
  }
  map && map.end();

  // append __weex_bootstrap__ for entry component
  // not impact sourcemap
  if (isEntry) {
    target += '\n;__weex_bootstrap__("@weex-component/' + name + '", ' + String(config) + ',' + String(data) + ')';
  }

  return Promise.resolve(prefix + target);
}